public static class Base64Encoder_####UUID####
{
    public static byte[] Decode(object input)
    {
        Console.WriteLine("[+] Decrypting from Base64");
        try 
        {
            // Handle byte array input
            if (input is byte[] inputBytes)
            {
                // Convert byte array to string
                string base64String = System.Text.Encoding.UTF8.GetString(inputBytes);
                
                // Check for invalid characters
                for (int i = 0; i < base64String.Length; i++)
                {
                    char c = base64String[i];
                    if (!IsValidBase64Char(c))
                    {
                        // Remove the last character if it's invalid
                        if (i == base64String.Length - 1)
                        {
                            base64String = base64String.Substring(0, base64String.Length - 1);
                        }
                    }
                }
                
                // Use .NET's built-in Base64 decoder with cleaned string
                return System.Convert.FromBase64String(base64String);
            }
            else
            {
                throw new ArgumentException("Input must be a byte array");
            }
        }
        catch (Exception ex)
        {
            throw new Exception($"Error decoding Base64: {ex.Message}", ex);
        }
    }
    
    private static bool IsValidBase64Char(char c)
    {
        return (c >= 'A' && c <= 'Z') || 
               (c >= 'a' && c <= 'z') || 
               (c >= '0' && c <= '9') || 
               c == '+' || c == '/' || c == '=';
    }
    
    private static string CleanBase64String(string input)
    {
        // Remove any characters that aren't valid in base64
        System.Text.StringBuilder sb = new System.Text.StringBuilder(input.Length);
        foreach (char c in input)
        {
            if (IsValidBase64Char(c))
            {
                sb.Append(c);
            }
        }
        
        // Ensure proper padding
        string result = sb.ToString().TrimEnd('=');
        int mod = result.Length % 4;
        if (mod != 0)
        {
            result = result.PadRight(result.Length + (4 - mod), '=');
        }
        
        return result;
    }
}