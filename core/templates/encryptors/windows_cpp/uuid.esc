int uuid_decode_####UUID####(unsigned char* encoded, int length) {
    printf("\n[-] Decoding from UUID\n");
    
    // Count the number of UUIDs in the string (each UUID is 36 characters)
    int uuid_count = length / 36;
    if (uuid_count == 0) {
        printf("[-] No valid UUIDs found in the input\n");
        return -1;
    }
    
    printf("[+] Found %d UUIDs to decode\n", uuid_count);
    
    // Allocate memory for UUID strings
    char** uuids = (char**)malloc(uuid_count * sizeof(char*));
    if (!uuids) {
        perror("Failed to allocate memory for UUID array");
        return -1;
    }
    
    // Parse UUID strings
    char* uuid_str = (char*)encoded;
    for (int i = 0; i < uuid_count; i++) {
        // Allocate memory for this UUID string (36 chars + null terminator)
        uuids[i] = (char*)malloc(37);
        if (!uuids[i]) {
            perror("Failed to allocate memory for UUID string");
            // Free previously allocated memory
            for (int j = 0; j < i; j++) {
                free(uuids[j]);
            }
            free(uuids);
            return -1;
        }
        
        // Copy UUID string (36 characters)
        strncpy(uuids[i], uuid_str + (i * 36), 36);
        uuids[i][36] = '\0';
    }
    
    // Allocate memory for binary UUIDs
    unsigned char* binary_uuids = (unsigned char*)malloc(uuid_count * 16);
    if (!binary_uuids) {
        perror("Failed to allocate memory");
        for (int i = 0; i < uuid_count; i++) {
            free(uuids[i]);
        }
        free(uuids);
        return -1;
    }

    // Convert the UUID strings to binary format and store them in the binary_uuids buffer
    for (int i = 0; i < uuid_count; i++) {
        UUID uuid;
        RPC_STATUS status = UuidFromStringA((RPC_CSTR)uuids[i], &uuid);
        if (status != RPC_S_OK) {
            printf("UuidFromStringA nÂ°%d failed with status %d\n", i, status);
            free(binary_uuids);
            for (int j = 0; j < uuid_count; j++) {
                free(uuids[j]);
            }
            free(uuids);
            return -1;
        }
        memcpy(binary_uuids + (i * 16), &uuid, 16);
    }
    
    // Calculate the actual decoded size
    int decoded_size = uuid_count * 16;
    
    // Ensure the decoded size is a multiple of 8 (DES3 block size)
    // This is critical for DES3 decryption to work properly
    if (decoded_size % 8 != 0) {
        printf("[!] Warning: Decoded size %d is not a multiple of 8 (DES3 block size)\n", decoded_size);
        // We don't need to pad here as the data should already be properly padded
    }
    
    // Copy the binary UUID data back to the encoded buffer
    memcpy(encoded, binary_uuids, decoded_size);

    // Free the UUID string segments
    for (int i = 0; i < uuid_count; i++) {
        free(uuids[i]);
    }
    free(uuids); // Free the array of UUID strings

    // Free the binary UUIDs buffer
    free(binary_uuids);

    printf("[+] UUID decoded %d bytes successfully\n", decoded_size);
    
    // Return the actual size of the decoded data
    return decoded_size;
}