int des3_decrypt_####UUID####(unsigned char* encoded, int length) {
    printf("\n[-] Decrypting from DES3\n");
    
    // Check if length is valid for DES3 (must be multiple of 8)
    if (length <= 0) {
        printf("[-] Invalid length: %d\n", length);
        return -1;
    }
    
    if (length % 8 != 0) {
        printf("[!] Warning: Length %d is not a multiple of 8 (DES3 block size)\n", length);
        // Adjust length to nearest multiple of 8
        length = (length / 8) * 8;
        printf("[+] Adjusted length to %d bytes\n", length);
    }
    
    unsigned char key[] = ####KEY####;
    int key_length = sizeof(key);
    unsigned char iv[] = ####IV####;
    int iv_length = sizeof(iv);

    // Try decryption without padding first
    BCRYPT_ALG_HANDLE hAlg = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    NTSTATUS status;
    DWORD cbKeyObject, cbData, dwLength = length;
    PBYTE pbKeyObject = NULL;

    // Open an algorithm handle
    status = BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_3DES_ALGORITHM, NULL, 0);
    if (!BCRYPT_SUCCESS(status)) {
        printf("[-] BCryptOpenAlgorithmProvider failed with status 0x%x\n", status);
        return -1;
    }

    // Set chaining mode to CBC
    status = BCryptSetProperty(hAlg, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    if (!BCRYPT_SUCCESS(status)) {
        printf("[-] BCryptSetProperty failed with status 0x%x\n", status);
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return -1;
    }

    // Calculate the size of the buffer to hold the KeyObject
    status = BCryptGetProperty(hAlg, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbData, 0);
    if (!BCRYPT_SUCCESS(status)) {
        printf("[-] BCryptGetProperty failed with status 0x%x\n", status);
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return -1;
    }

    // Allocate the key object
    pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
    if (NULL == pbKeyObject) {
        printf("[-] Memory allocation failed for key object\n");
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return -1;
    }

    // Generate the key from supplied input key bytes
    status = BCryptGenerateSymmetricKey(hAlg, &hKey, pbKeyObject, cbKeyObject, key, key_length, 0);
    if (!BCRYPT_SUCCESS(status)) {
        printf("[-] BCryptGenerateSymmetricKey failed with status 0x%x\n", status);
        HeapFree(GetProcessHeap(), 0, pbKeyObject);
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return -1;
    }

    // Allocate buffer for decrypted data
    unsigned char* decrypted = (unsigned char*)HeapAlloc(GetProcessHeap(), 0, length);
    if (decrypted == NULL) {
        printf("[-] Memory allocation failed for decrypted buffer\n");
        BCryptDestroyKey(hKey);
        HeapFree(GetProcessHeap(), 0, pbKeyObject);
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return -1;
    }

    // First try: Decrypt without padding
    status = BCryptDecrypt(hKey, encoded, length, NULL, iv, iv_length, decrypted, length, &dwLength, 0);
    
    // If that fails, try with padding
    if (!BCRYPT_SUCCESS(status)) {
        printf("[!] Decryption without padding failed, trying with PKCS7 padding...\n");
        status = BCryptDecrypt(hKey, encoded, length, NULL, iv, iv_length, decrypted, length, &dwLength, BCRYPT_BLOCK_PADDING);
    }
    
    if (!BCRYPT_SUCCESS(status)) {
        printf("[-] BCryptDecrypt failed with status 0x%x\n", status);
        
        // Try one more approach - manual decryption of each block
        printf("[!] Trying block-by-block decryption...\n");
        
        // Reset IV for block-by-block approach
        unsigned char current_iv[8];
        memcpy(current_iv, iv, 8);
        
        BOOL block_success = TRUE;
        for (int i = 0; i < length; i += 8) {
            // Decrypt one block
            status = BCryptDecrypt(hKey, encoded + i, 8, NULL, current_iv, 8, decrypted + i, 8, &cbData, 0);
            if (!BCRYPT_SUCCESS(status)) {
                printf("[-] Block %d decryption failed with status 0x%x\n", i/8, status);
                block_success = FALSE;
                break;
            }
            
            // Use current ciphertext as next IV (CBC mode)
            memcpy(current_iv, encoded + i, 8);
        }
        
        if (!block_success) {
            HeapFree(GetProcessHeap(), 0, decrypted);
            BCryptDestroyKey(hKey);
            HeapFree(GetProcessHeap(), 0, pbKeyObject);
            BCryptCloseAlgorithmProvider(hAlg, 0);
            
            // As a last resort, just return the data as-is
            printf("[!] All decryption attempts failed. Returning data as-is.\n");
            return length;
        }
        
        dwLength = length;
    }

    // Copy decrypted data back to encoded buffer
    memcpy(encoded, decrypted, dwLength);
    
    // Clean up
    HeapFree(GetProcessHeap(), 0, decrypted);
    BCryptDestroyKey(hKey);
    HeapFree(GetProcessHeap(), 0, pbKeyObject);
    BCryptCloseAlgorithmProvider(hAlg, 0);

    printf("[+] DES3 decryption successful, output length: %d\n", dwLength);
    return dwLength;
}